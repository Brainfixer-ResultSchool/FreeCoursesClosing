# FreeCoursesClosing

## HTML-CSS

1. [Task 1](https://brainfixer-resultschool.github.io/FreeCoursesClosing/HTML-CSS/1/)

   ![Рисунок 1_1](HTML-CSS/1/1_1.png)

   Задание:

   Сверстать блок, изображенный на рисунке 1_1.

   Требования:

   1.1 Использовать исключительно HTML и CSS.

   1.2 Не использовать изображения (ни в теге img, ни в свойстве background-image/background).

   1.3 Букву R выполнить ссылкой, ведущей на сайт https://result.school.

   1.4 Блок должен занимать 70-80 процентов от минимального размера вьюпорта и располагаться строго по его середине.

   1.5 Блок должен быть "резиновым", пропорционально изменяя свои размеры при изменении размеров окна браузера.

   1.6 При наведении на букву R она должна изменять цвет и слегка масштабироваться, как на рисунке 1_2. Изменения должны происходить плавно.

   ![Рисунок 1_2](HTML-CSS/1/1_2.png)

2. [Task 2](https://brainfixer-resultschool.github.io/FreeCoursesClosing/HTML-CSS/2/)

   ![Рисунок 2_1](HTML-CSS/2/2_1.png)

   Задание:

   Сверстать одностраничное приложение, изображенное на рисунке 2_1.

   Требования:

   2.1 Использовать исключительно HTML и CSS (без Javascript).

   2.2 При нажатии кнопок ширина верхней полосы прогресса должна меняться по принципу: нажата первая кнопка - ширина полосы 20%, нажата вторая - 40% и т.д. до пятой, при нажатии которой ширина полосы прогресса увеличивается до 100%. Цвет фона кнопок до нажатой и её включительно также должен меняться. Принцип работы показан на рисунках 2_2 и 2_3. Изменение ширины блоков полосы прогресса должно происходить плавно.

   ![Рисунок 2_2](HTML-CSS/2/2_2.png)
   ![Рисунок 2_3](HTML-CSS/2/2_3.png)

   2.3 Блоки должны располагаться строго по середине вьюпорта.

   2.4 Приложение должно быть "резиновым" и пропорционально менять размеры при изменении ширины вьюпорта. Кроме того, приложение должно быть адаптивным. При разрешении меньше 600 пикселей кнопки должны становиться вертикально.

   ![Рисунок 2_4](HTML-CSS/2/2_4.png)

   2.5 При наведении на кнопки мышки цвет их фона должен меняться. Изменения должны происходить плавно.

3. [Task 3](https://brainfixer-resultschool.github.io/FreeCoursesClosing/HTML-CSS/3/)

   ![Рисунок 3_1](HTML-CSS/3/3_1.png)

   Задание:

   Сверстать одностраничное приложение, изображенное на рисунке 3_1.

   Требования:

   3.1 Использовать исключительно HTML и CSS (без Javascript).

   3.2 Карточка представляет собой двухсторонний блок. При наведении мышки на её лицевую сторону карточка должна плавно перевернуться вокруг вертикальной оси и показать свою оборотную сторону.

   ![Рисунок 3_2](HTML-CSS/3/3_2.png)

   3.3 На обратной стороне карточки располагаются три переключающихся вкладки. При нажатии на вкладку она должна активироваться - менять цвет и включать соответствующий вкладке текстовый блок. Изменение цвет и переключение блоков должно быть плавным.

   ![Рисунок 3_3](HTML-CSS/3/3_3.png)
   ![Рисунок 3_4](HTML-CSS/3/3_4.png)

   3.4 Карточка должна располагаться строго посередине вьюпорта.

   3.5 Приложение должно быть "резиновым" и пропорционально менять размеры при изменении ширины вьюпорта.

## Marathon

1. [Task 1](https://brainfixer-resultschool.github.io/FreeCoursesClosing/Marathon/1/)

   Задание:

   Создать веб-приложение, которое позволяет пользователю изменять цвет фона страницы по клику на единственную кнопку.

   Требования:

   1.1 Код должен быть написан исключительно на Javascript без использования HTML/CSS в отдельном(-ых) файле(-ах). В файле index.html должна быть единственная строчка – подключение файла app.js. Использование сторонних библиотек также не допускается :). Дизайн приложения – на усмотрение разработчика.

   1.2 На странице должна быть динамически сгенерированная и добавленная посредством Javascript кнопка с текстом "Изменить цвет".

   1.3 При клике на кнопу цвет фона страницы должен измениться на случайный, заданный в HEX-формате (шесть шестнадцатиричных символов от `0` до `F`, следующие за знаком хештега `#`) Функционал генерации случайного цвета должен быть вынесен в отдельную функцию `getRandomColor()`.

   1.4 Событие клика должно быть подключено к объекту `document` с помощью метода `addEventListener()`.

   1.5 Весь код (для порядка :) ) должен быть выполнен после полной загрузки DOM-дерева. Для этого необходимо использовать событие `DOMContentLoaded`.

2. [Task 2](https://brainfixer-resultschool.github.io/FreeCoursesClosing/Marathon/2/)

   Задание: Создать функцию, которая принимает массив объектов с информацией о студентах и возвращает объект с тремя группами студентов, отсортированными по среднему баллу.

   Требования:

   2.1 Функция обработки информации о студентах должна называться `groupAndSortStudents()` и принимать на вход массив объектов, каждый из которых содержит три поля – имя студента `name`, возраст студента `age` и средний балл успеваемости студента (от 0 до 5) `grade`.

   2.2 Объект, который должна вернуть функция, представляет собой объект из трёх массивов, хранящихся в свойствах (по ключам) `under20` (студенты младше 20 лет), `20to30` (студенты от 20 до 30 лет включительно), `over30` (студенты старше 30 лет).

   2.3 В каждом из трёх массива должна находится информация о студентах соответствующих возрастов.

   2.4 В массивах студенты должны быть отсортированы по убыванию средних баллов успеваемости.

   2.5 Если в группе нет студентов, массив должен остаться пустым.

   2.6 Для обработки информации обязательно использоваться методы массивов (по необходимости – `forEach()`, `sort()`, `push()`, `reduce()`...)

   2.7 Работу функции можно протестировать на массиве:

   `[
   { name: 'Алексей', age: 18, grade: 4.5 },
   { name: 'Мария', age: 22, grade: 4.8 },
   { name: 'Иван', age: 27, grade: 4.2 },
   { name: 'Анна', age: 19, grade: 4.9 },
   { name: 'Сергей', age: 24, grade: 4.3 },
];`

   2.8 Результат работы функции необходимо вывести в консоль. Ожидаемый результат с данными из п. 2.7:

   `{
under20: [
   { name: 'Анна', age: 19, grade: 4.9 },
   { name: 'Алексей', age: 18, grade: 4.5 }
],
'20to30': [
   { name: 'Мария', age: 22, grade: 4.8 },
   { name: 'Сергей', age: 24, grade: 4.3 }
],
over30: [ { name: 'Иван', age: 27, grade: 4.2 } ]
}`

3. [Task 3](https://brainfixer-resultschool.github.io/FreeCoursesClosing/Marathon/3/)

   Задание: Создать веб-приложение, которое загружает список пользователей с API `https://jsonplaceholder.typicode.com/users`, отображает их в виде карточек и позволяет фильтровать по имени через поле ввода.

   Требования:

   3.1 Код должен быть написан исключительно на Javascript без использования HTML/CSS в отдельном(-ых) файле(-ах). В файле index.html должна быть единственная строчка – подключение файла app.js. Использование сторонних библиотек также не допускается :). Дизайн приложения – на усмотрение разработчика. При необходимости, стили могут быть добавлены динамически посредством Javascript элементом `style`.

   3.2 На странице должны быть динамически сгенерированы поле ввода для поиска пользователя по имени и контейнер для отображения карточек с информацией о пользователях.

   3.3 Каждая карточка пользователя должна содержать информацию об имени пользователя `name`, его электронной почте `email` и номере телефона `phone`.

   3.4 Карточки пользователя должны генерироваться динамически в контейнер по п. 3.3 после загрузки информации с API. Функционал генерации карточек должен быть вынесен в отдельную функцию `renderUsers()`.

   3.5 Для загрузки информации необходимо использовать сервис `https://jsonplaceholder.typicode.com/users`. Информация должна загружаться однократно при старте приложения. Информация должна загружаться асинхронно с использованием метода `fetch()`. Можно использовать `async/await` или промисы в чистом виде. Функционал загрузки информации должен быть вынесен в отдельную функцию `fetchUsers()`.

   3.6 Ошибки загрузки данных с сервера должны перехватываться. При появлении ошибки в контейнере вместо карточек с пользователями должно выводится сообщение об ошибке.

   3.7 При вводе текста в поле поиска список отображаемых на странице пользователей должен фильтроваться, осуществляя поиск нужного пользователя (без учёта регистра ввода), чьё имя содержит введённую подстроку. Фильтрация должна выполняться в реальном времени по событию `input` поля ввода. Можно использовать самостоятельно написанные методы `debounce()` или `throttle()`.

   3.7 Весь код (для порядка :) ) должен быть выполнен после полной загрузки DOM-дерева. Для этого необходимо использовать событие `DOMContentLoaded`.
